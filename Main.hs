module Main where

import Test.QuickCheck

main = undefined

-- Multiples of 3 and 5
-- Problem 1

-- If we list all the natural numbers below 10 that are multiples of 3
-- or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.

-- Find the sum of all the multiples of 3 or 5 below 1000.

divByN :: Int -> Int -> Bool
divByN = ((==0) .) . mod

divByThreeOrFive :: Int -> Bool
divByThreeOrFive = \n -> divByN n 3 || divByN n 5

problem1 :: Int
problem1 = sum $ filter divByThreeOrFive [1..999]

-- Even Fibonacci numbers
-- Problem 2

-- Each new term in the Fibonacci sequence is generated by adding the
-- previous two terms. By starting with 1 and 2, the first 10 terms
-- will be:

-- 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

-- By considering the terms in the Fibonacci sequence whose values do
-- not exceed four million, find the sum of the even-valued terms.

fourMil = 4 * 10 ^ 6

fib :: Int -> Int
fib 0 = 1
fib 1 = 2
fib n = fib (n-1) + fib (n-2)

problem2 :: Int
problem2 = (\n -> sum $ filter even $ takeWhile (<n) $ map fib [0..]) 4000000

-- Largest prime factor -- Problem 3

-- The prime factors of 13195 are 5, 7, 13 and 29.

-- What is the largest prime factor of the number 600851475143 ?

number = 600851475143

largestDivisor :: Int -> Int
largestDivisor n = go n [2..]
  where go n (x:xs) =
          if mod n x == 0
          then if div n x == 1
               then x
               else go (div n x) (x:xs)
          else go n xs

problem3 :: Int
problem3 = largestDivisor number

-- Largest palindrome product
-- Problem 4

-- A palindromic number reads the same both ways. The largest
-- palindrome made from the product of two 2-digit numbers is 9009 =
-- 91 × 99.

-- Find the largest palindrome made from the product of two 3-digit
-- numbers.

isPalindromic :: Int -> Bool
isPalindromic n = show n == (reverse $ show n)

threeDigits = [100..999]

products :: [Int] -> [Int]
products xs = [ x*y | x <- xs, y <- xs ]

problem4 :: Int
problem4 = maximum $ filter isPalindromic $ products threeDigits

-- Smallest multiple
-- Problem 5

-- 2520 is the smallest number that can be divided by each of the
-- numbers from 1 to 10 without any remainder.

-- What is the smallest positive number that is evenly divisible by
-- all of the numbers from 1 to 20?

-- contextAll :: (Int -> Bool) -> [Int] -> Bool
-- contextAll = all

-- contextFoldl :: (Int -> Int -> Int) -> Int -> [Int] -> Int
-- contextFoldl = foldl

-- -- this function will take [1..20] and 2432902008176640000, and return true
-- divByAll :: Int -> [Int] -> Bool
-- divByAll m ns = all (\n -> m `divByN` n) ns

-- lCM :: [Int] -> Int
-- lCM ns = minimum $ filter (`divByAll` ns) $ [1..10000000] 

-- problem5 :: Int
-- problem5 = lCM [1..20]

-- A simple algorithm

-- This method works as easily for finding the LCM of several
-- integers.

-- Let there be a finite sequence of positive integers X = (x1, x2,
-- ..., xn), n > 1. The algorithm proceeds in steps as follows: on
-- each step m it examines and updates the sequence X(m) = (x1(m),
-- x2(m), ..., xn(m)), X(1) = X, where X(m) is the mth iteration of X,
-- i.e. X at step m of the algorithm, etc. The purpose of the
-- examination is to pick the least (perhaps, one of many) element of
-- the sequence X(m). Assuming xk0(m) is the selected element, the
-- sequence X(m+1) is defined as

--     xk(m+1) = xk(m), k ≠ k0
--     xk0(m+1) = xk0(m) + xk0(1).

-- In other words, the least element is increased by the corresponding
-- x whereas the rest of the elements pass from X(m) to X(m+1)
-- unchanged.

-- The algorithm stops when all elements in sequence X(m) are equal.
-- Their common value L is exactly LCM(X).

-- (2,3,4) -> (4,3,4) -> (4,6,4) -> (6,6,8) -> (4,9,8) -> (4,9,12)
-- -> ... -> (12,12,12)

-- ([2,3,4], [2,3,4])
-- ([2,3,4], [4,6,4])
-- ([2,3,4], [6,6,8])
-- ([2,3,4], [8,9,8])
-- ([2,3,4], [10,9,12])
-- ([2,3,4], [12,12,12])

-- ([2,3,4], [4,6,4], False) -> [6,6,8]

-- take indexes of elements that are not maximum value

-- [4,6,4] -> [0,2]

-- [4,6,4] -> [Maybe 0, Nothing, Maybe 2]

-- [4,6,4] -length-> 3 -maximum-> 6 ->

data LCMAlgo =
  LCMAlgo { original :: [Int]
          , current :: [Int]
          , len :: Int
          , allEqB :: Bool
          }
  deriving Show

lcmalgo = LCMAlgo [2,3,4] [4,6,4] 3 True


-- lCM xs = if allEqual xs then head xs
--          else incrementElements xs xs

-- incrementElements :: [Int] -> [Int] -> [Int]
-- incrementElements (x:y:ys) = undefined


allEqual :: Eq a => [a] -> Bool
allEqual [] = True
allEqual [x] = True
allEqual (x:y:ys)
  | x == y = allEqual (y:ys)
  | otherwise = False

-- getIndices [2,3,6,4,6] --> [0,1,3]
getIndices :: [Int] -> [Int]
getIndices xs = [ i | i <- [0..(length xs)-1], xs !! i < maximum xs ]

getIndicesR :: [(Int, Int)] -> [Int]
getIndicesR = getIndices . map snd

-- update [(2,4),(3,6),(4,4)] [0,2] --> [(2,6),(3,6),(4,8)]
update :: [(Int, Int)] -> [Int] -> [(Int, Int)]
update xys indices = [ let (x, y) = (xys !! i)
                       in (x, go i x y)
                     | i <- [0..(length xys)-1]
                     ]
  where go i x y =
          if i `elem` indices then x + y else y

lCMRecursion :: [(Int, Int)] -> [Int] -> Int
lCMRecursion xys is =
  let ys = map snd xys
  in if allEqual ys
     then head ys
     else let xys' = update xys is
              is' = getIndicesR xys'
          in lCMRecursion xys' is'

lCM :: [Int] -> Int
lCM xs = lCMRecursion (zip xs xs) $ getIndices xs

problem5 :: Int
problem5 = lCM [1..20]

lCMList :: [Int] -> Int
lCMList [x] = x
lCMList (x:y:ys) = lCMList (lCM [x,y] : ys)
